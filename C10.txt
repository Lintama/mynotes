第十章  数组和指针

数组的初始化
int num[3]={1,2,3}
未初始化 垃圾值
已初始化 少打项数  初始为0  char类型初始为' '
多打 编译器提示错误
int ch[5]={1,2,3,4} 部分初始化  ch[4]=0
int ch[ ]={1,2,3,4} 自动确定数组大小 ch[4]为垃圾值

指定初始化器
int arr[6]={ [5]=12 };
其他未初始化的元素都会被设置为0   C99新特性 VC++报错 Dev不报错

int arr[6]={1,2,3,4,[4]=5,6,[5]=5}  arr[5]被改变
int arr[]={[3]=1,2,3} 数组的大小为6个元素


编译器不会检查下表是否正确 
即不检查边界


C99新特性：变长数组variable-length arry VLA
int i=4;
int arr[i];  但是VLA不可初始化
C99之前[]中必须为整形常量表达式  VC++报错 Dev不报错 (似乎VC++不支持C99之后的标准)


float rain[5][12] 
rain是一个内含5个元素的数组
rain的每个元素都是一个内含12个float类型值的数组

二维数组初始化
int sq[2][3] = {{5,6},
                {7,8}}
5 6 0
7 8 0

int sq[2][3] = {5,6,7,8}

5 6 7
8 0 0


数组名是数首元素的地址  
int arr[]

arr == &arr[0]

arr+1      等于 arr[1]的地址
short
0x7fff5fbffdc   0x7fff5fbffde
double
0x7fff5fbff8a0  0x7fff5fbff8a8

系统中 地址按字节编址 short 2字节 double 8字节
C中 指针+1指的是增加一个 【存储单元】  所以对数组来说
+1后的地址是下一个元素的地址而不是 【下一个字节】 的地址
必须要声明指针所指向对象类型的原因之一 要让计算机知道存储对象需要多少字节 
如 因为pti的类型是short 所以指针+1 其值每次递增2字节

数组名是一个地址常量 
通过函数调用时实参为一个地址 则应定义一个指针变量作为形参
因此 arr + 2 = &arr[2]
     *(arr + 2) = arr[2]


只有在原型或者定义时 形参 才能用int arr[]代替 int *arr
在声明时
int *ar
int *
int ar[]
int [] 等价


不要解引用未初始化的指针
int * p;
*p = 5;p指向的位置不确定


编写一个函数时 要选择传递值还是传递地址
而对于数组来说 别无选择 必须传递地址
所以若不小心容易改变数组中的值
因此
在声明和定义时使用
int sum(const int ar[]);可保护数组中的数据


int c[4]={1,2,3,4}
int * p = c;
p[1] = c[1] = 2
若 p = c+1
p[1] = 3 
c[1] = 2
进一步说明了数组的实质是在变相使用指针
只不过分为数组表示法和指针表示法

const int * p = c;
不能通过p[1]=xxx改变数组的元素
指向const的指针通常用于函数形参 表明该函数不会使用指针改变数据
void arr(const double *ar,int n);
不能把const数据的地址赋给普通指针（否则通过指针就能改变const的值）
(但是只给个warning 实际上可以改)
因此 对函数的形参使用const不仅能保护数据 还能让函数处理const数组



还可以声明一个不能指向别处的指针
int * const p = rates;
也可 
const int * const p = rates;
使p指针既不能改变所指向的值 又不能指向别的地址



指针和多维数组
int z[4][2];
z是首元素的地址 z的首元素是一个内含两个int值的数组
所以z为这个数组的地址

z == &z[0]
z[0]==&z[0][0]
指针或地址+1 其值会增加对应类型的数值
z+1 和z[0]+1 不同 因为z指向的对象占两个int大小 z[0]指向的对象占1个
z为地址的地址

int (* pz)[2]; pz指向一个含有两个int类型值的数组

p --> p[0]-->p[0][0] p[0][1]
      p[1]-->p[1][0] p[1][1]
      p[2]-->p[2][0] p[2][1]
P304







 


























