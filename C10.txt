第十章  数组和指针

数组的初始化
int num[3]={1,2,3}
未初始化 垃圾值
已初始化 少打项数  初始为0  char类型初始为' '
多打 编译器提示错误
int ch[5]={1,2,3,4} 部分初始化  ch[4]=0
int ch[ ]={1,2,3,4} 自动确定数组大小 ch[4]为垃圾值

指定初始化器
int arr[6]={ [5]=12 };
其他未初始化的元素都会被设置为0   C99新特性 VC++报错 Dev不报错

int arr[6]={1,2,3,4,[4]=5,6,[5]=5}  arr[5]被改变
int arr[]={[3]=1,2,3} 数组的大小为6个元素


编译器不会检查下表是否正确 
即不检查边界


C99新特性：变长数组variable-length arry VLA
int i=4;
int arr[i];  但是VLA不可初始化
C99之前[]中必须为整形常量表达式  VC++报错 Dev不报错 (似乎VC++不支持C99之后的标准)


float rain[5][12] 
rain是一个内含5个元素的数组
rain的每个元素都是一个内含12个float类型值的数组

二维数组初始化
int sq[2][3] = {{5,6},
                {7,8}}
5 6 0
7 8 0

int sq[2][3] = {5,6,7,8}

5 6 7
8 0 0


数组名是数首元素的地址  
int arr[]

arr == &arr[0]

arr+1      等于 arr[1]的地址
short
0x7fff5fbffdc   0x7fff5fbffde
double
0x7fff5fbff8a0  0x7fff5fbff8a8

系统中 地址按字节编址 short 2字节 double 8字节
C中 指针+1指的是增加一个 【存储单元】  所以对数组来说
+1后的地址是下一个元素的地址而不是 【下一个字节】 的地址
必须要声明指针所指向对象类型的原因之一 要让计算机知道存储对象需要多少字节 
如 因为pti的类型是short 所以指针+1 其值每次递增2字节


因此 arr + 2 = &arr[2]
     *(arr + 2) = arr[2]





































